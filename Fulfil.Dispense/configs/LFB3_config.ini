[LFB_config]                                   ; configuration for LFB

;// The outer dimensions of the physical LFR bot
;// Usage: DropTarget Algorithm in calculations for target Limits as provided by VLSG
;// Frequency of change: extremely rare. Only if bot dimensions change
LFB_width = 0.53                               ; unit: meters
LFB_length = 0.40                              ; unit: meters

;// The outer dimensions of the LFR bag container
;// Usage: a few checks in Drop Target Algorithm for valid inputs and target results. Largely replace by container_width and container_length
;// Frequency of change: extremely rare. Only if bot dimensions change
LFB_bag_width = 0.45                           ; unit: meters
LFB_bag_length = 0.32                          ; unit: meters

;// The height from the bottom of the LFR platform adjustment to the marker surface plane
;// The bottom of LFR platform is a recipe set in Mongo Rover recipes
;// Usage: Drop Target Algorithm, Pre/Post Compare Algorithm, Fit in Bag checks
;// Frequency of change: common. This should be read from a mongo recipe so there are no disconnections here.
LFB_cavity_height = 0.30                       ; unit: meters

;// Added for extend collision reduction
extend_depth_analysis_over_markers = true
should_filter_out_white = false

;// The remaining adjustability of the LFR platform when the bag is empty and the lift is set to a default value
;// This depends on multiple recipe values in Mongo rover recipes
;// Usage: This is not currently used in any meaningful way in the codebase.
;// Frequency of change: common. This should be read from a mongo recipe so there are no disconnections here.
initial_remaining_platform = 0.210              ; unit: meters

;// The dimensions of the LFR bag to be used for constructing the Container class. Generally slightly smaller than the Bag dimensions
;// Usage: any time a Container is used, so pretty much every algorithm related to the LFR depth camera.
;// Frequency of change: rare
container_width = 0.43                          ; unit: meters
container_length = 0.30                         ; unit: meters

;// In the past this config was used to calculate the container dimensions in many cases relative to the LFR bag cavity dimensions.
;// Since individual container dimensions were added, as defined above, the edge_avoidance_offset value was removed from a lot of places.
;// Usage: it is still used for the Drop Target evaluation for Empty bags
;// Frequency of change: rare
edge_avoidance_offset = 0.001                    ; unit: meters

;// Defines the offset from the front and left edges of the LFR container for use in creating the Drop Target for empty bags.
;// Frequency of change: rare
front_edge_target_offset = 0.005                  ; unit: meters
port_edge_target_offset = 0.0                  ; unit: meters
rear_edge_target_offset = 0.005                  ; unit: meters
starboard_edge_target_offset = 0.0              ; unit: meters


;// Defines the inner region of the LFR bag container vs. the outer perimeter of the LFR bag container. Percentage of width and height to use.
;// Usage: color filtering when used for adjusting depth detections for the bag. We only adjust depth detections on the perimeter,
;// so as not to improperly adjust items that are in the bag as much as possible
;// Frequency of change: on occasion
fraction_of_bag_dims_considered_inner_bag = 0.85   ; unit: percentage

;// After valid candidate regions for drop target are found, this value dictates how to further reduce the candidates to speed up processing.
;// Usage: Drop Target Algorithm for bags that are not empty
;// Frequency of change: rare
only_consider_every_Xth_target_candidate = 5     ; unit: count

;// These are the coordinates of the specific feature points of Aruco markers 0 - 7 in the local LFR container frame.
;// Origin is in the center of the LFR container. See Depth Cam diagrams for more information.
;// The specific corner that is used for each marker is specified in marker_detector_container.h as well
;// Usage: Kabsch transform and creation of local containers for local point cloud processing
;// Frequency of change: rare
marker_coordinates_x = 0.23425 -0.23425 -0.23425 -0.248 -0.248 0.248 0.248 0.23425   ; unit: meter
marker_coordinates_y = -0.125 -0.125 -0.015 0.044 0.125 0.125 0.015 -0.044           ; unit: meter
marker_coordinates_z = 0 0 0 0 0 0 0 0                                               ; unit: meter

;// This boolean sets whether to use the Y pixel coordinates of detected markers on the bot to do an orientation check on the bot
;// during Drop Target algorithm processing. If set to false, X coordinates are used.
;// The historical need for this flag was to use different pixel values for different bot versions (LFR2 vs. LFR3) which were
;// themselves rotated from each other.
;// Usage: Drop Target Algorithm, verifying orientation of bot
;// Frequency of change: never, will always be the same for a given bot type
use_y_coordinates_orientation_check = true       ; unit: bool

;// This is a relic of an old method of ensuring the container transform worked even when few markers were detected.
;// Usage: no longer used, can be removed from codebase.
;// Frequency of change: never
marker_adjust_amount = 0.00                      ;  unit: meters

;// Detected Aruco markers during various CV requests are only deemed Valid in first past validation check if they are within these
;// pixel bounds on the image. This rectangular region can be visualized in offline simulation.
;// Usage: filtering out valid vs. invalid marker detections. Used to be very important to ignore neighboring bots at same VLS.
;// Frequency of change: rare
region_max_x = 1150                              ; unit: pixel
region_min_x = 150                               ; unit: pixel
region_max_y = 700                               ; unit: pixel
region_min_y = 70                                ; unit: pixel

;// Boolean feature flag and associated values for a more extensive marker validation location check
;// and also a boolean to dictate which axis (y or x) is used for the validation check
;// Usage: confirming that bot is centered under the camera
;// Frequency of change: rare
extra_marker_validation_required = false         ; unit: bool
min_dim_1 = 150                                 ; unit: pixel, min dimension pixel value for markers: 1, 2, 3, 4  (for nominal bot rotation status)
max_dim_1 = 550                                 ; unit: pixel, max dimension pixel value for markers: 1, 2, 3, 4  (for nominal bot rotation status)
min_dim_2 = 750                                 ; unit: pixel, min dimension pixel value for markers: 0, 5, 6, 7  (for nominal bot rotation status)
max_dim_2 = 1150                                ; unit: pixel, max dimension pixel value for markers: 0, 5, 6, 7  (for nominal bot rotation status)
extra_check_in_y_coordinates = false            ; unit: bool,  true: extra dimension check in y pixel coordinates, false: in x pixel coordinates.

;// Boolean feature flag for allowing Drop Target algorithm to provide drop targets that require Pirouette routine
;// We always allow pirouetting now, this can be removed from the codebase
;// Usage: Drop Target Algo
;// Frequency of change: never.
rotation_allowed = true                         ; unit: bool
; rotation_allowed = false                         ; unit: bool

;// Boolean feature flag for allowing Drop Target algorithm to provide drop targets that require Pirouette routine
;// We always allow pirouetting now, this can be removed from the codebase
;// Usage: Drop Target Algo
;// Frequency of change: never
rotate_LFB_viz = true                           ; unit: bool


;// Definitions for creating the Aruco Marker dictionary system for markers 0-7 of the appropriate design size
;// Frequency of change: never
num_markers = 8                                 ; unit: number
marker_size = 4                                 ; unit: number (defines nxn white squares in the marker region)

;// Expected depth of Aruco markers in camera coordinate frame. The tolerance really could be a lot smaller here.
;// Usage: for marker validation purposes in Marker Detector Container
;// Frequency of change: rarely, only if distance b/w camera and bot change
marker_depth = 0.82                             ; in meters
marker_depth_tolerance = 0.5                    ; in meters

;// Acceptable difference in Remaining_Platform input from VLSG for the Pre/Post image comparison
;// Usage: Pre/Post image comparison for item-in-bag detection
;// Frequency of change: rarely. Making this any larger will affect the item-in-bag sensor accuracy
allowable_platform_difference = 0.005           ; in meters, between pre and post images

;// Threshold for average depth of bag contents when LFR platform is bottomed out, for which bag is determined FULL.
;// TODO: REMOVE THIS FUNCTIONALITY AND THIS FIT CHECK! No longer necessary and overly restrictive.
;// Usage: Drop Target request, one of the bag too full checks
;// Frequency of change: never
bag_full_threshold_meters = 0.05                ; unit: meters

;// Percentage of dispensed item length that is allowed to stick out above marker surface after dispense (predicted)
;// TODO: align this with a similar Mongo recipe used by .NET stack. Universal VLS recipe --> dispense recipes most likely
;// Usage: Drop Target algo, item fit in bag checks and target candidate analysis
;// Frequency of change: on occasion. Can try increasing this to optimize bag packing as long as items
;// dont start falling out of bag at dispense
max_item_length_percent_overflow = 0.6          ;
allowed_item_overflow_pre_dispense=0.016
allowed_item_overflow_post_dispense_check=0.016

;// Values to define construction of Drop Grid AND Mongo Bag State Tracking objects.
;// Note: "channels" is only used in the Mongo Bag State tracking and indicates how many layers to the map are used.
;// Warning: some of the current Mongo Bag State class handling ONLY allows up to 3 channels, do not increase beyond 3.
;// Usage: Pre/Post image comparison, streamlined check for future products fitting in bag, bag state tracking + damage risk assessment
;// Frequency of change: rarely
grid_rows = 8;  for use in bag state tracking
grid_cols = 6;
grid_channels = 3 ; Should this be the same as damage_layers_to_include?
avoid_metal_on_metal=true

;// These values indicate how Bag State damage risk assessment occurs. The risk assessment highlights grid regions of the bag
;// in red that contain damage risk items. And yellow regions where a center of a drop target for the dispensed item would lead
;// to the item hitting a red risk region. The damage_swing_factor is included in that calculation.
;// layers_to_include indicates how many layers deep items are considered as risky based on their damage risk codes.
;// damage buffer width and length increase the yellow keep out region beyond the original calculation by a certain number of
;// squares on each side, in alignment with the bot width or length.
;// Frequency of change: on occasion the buffer length and width are changed to be more conservative / liberal in avoiding damage interactions
damage_buffer_width = 1; for use in assessing damage risk in mongo_bag_state
damage_buffer_length = 0;
damage_swing_factor = 0.5;
;damage_layers_to_include = 3;
damage_layers_to_include = 1;

;// These values define how the Pre/Post image Drop Grids average depths are compared and whether an item is determined to have been dispensed.
;// The comparison for each individual grid cell must surpass the baseline_threshold or a depth_factor_correction times the item's dimension,
;// whichever is HIGHER. The logic there is that for large items, the depth difference should be expected to be larger if an item is present.
;// There is also a global comparison across the entire grid, and that is controlled by depth_total_threshold.
;// Frequency of change: COMMON! This is the primary method of optimizing the item-in-bag sensor detection, depth comparison
depth_baseline_average_threshold = 0.02; ;//for use in depth pre-post comparison processing
depth_factor_correction = 0.3;
depth_total_threshold = 0.115;

;// These values define how the Pre/Post image RGB channel comparisons occur. See algorithm in code for more information.
;// This comparison is only used if the depth comparison is inconclusive, so it is not changed as frequencyly.
;// Frequency of change: somewhat common.
bgSubHistory = 5000;
bgSubVarianceThresh = 1000.0     ; ;//Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample
bgSubDetectShadows = false       ; ;//If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.
RGB_average_threshold = 85;
RGB_total_threshold = 150;

;// Fulfil Bag HSV values
H_low = 63.72;
H_high = 81.18;
S_low = 0.0;
S_high = 255.0;
V_low = 0.0;
V_high = 255.0;
