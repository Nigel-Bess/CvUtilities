<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - interactive cubes (gpu)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #000;
            color: #444;
        }

        a {
            color: #08f;
        }
    </style>
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - gpu picking
    </div>
    <div id="container"></div>
    <script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.173.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.173.0/examples/jsm/"
				}
			}
		</script>
    <script type="module">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        let container, stats;
        let camera, controls, scene, renderer;
        let pickingTexture, pickingScene;
        let highlightBox;
        const pointer = new THREE.Vector2();
        const offset = new THREE.Vector3(10, 10, 10);
        const clearColor = new THREE.Color();

        const raw = prompt("Enter depthcam JSON:", '{"Error":0,"Error_Description":"","Grid_Square_Height_Mm":7,"Grid_Square_Width_Mm":11,"Occupancy_Map":[[396,396,270,0,0,0,381,359,0,357,0,0,291,294,297,307,311,313,290,0,400,408,412,411,384,399,400,402,403,391],[394,269,270,0,0,0,380,381,367,362,0,297,290,293,297,306,312,315,316,381,381,401,412,0,0,0,0,375,354,348],[0,267,271,287,0,397,399,383,378,364,0,292,289,295,298,304,312,315,318,0,0,402,403,404,404,394,376,372,361,354],[398,264,268,290,0,396,398,384,384,365,0,291,291,294,298,305,311,318,319,0,0,0,402,405,405,394,387,377,367,355],[395,263,284,291,296,376,380,380,365,362,0,291,290,294,298,305,306,0,0,0,0,0,0,406,405,392,384,376,361,358],[396,262,283,289,293,375,375,359,365,353,310,291,290,292,292,303,368,366,370,372,380,0,339,398,399,391,377,364,359,351],[399,260,285,290,292,292,343,351,352,352,301,287,287,295,298,301,365,368,369,373,375,0,338,387,386,384,374,359,356,343],[400,347,288,0,0,0,339,344,343,333,292,280,267,296,309,326,365,368,373,376,377,0,335,335,337,337,0,0,286,283],[399,0,0,329,335,338,340,333,324,321,310,308,301,295,314,326,364,369,373,377,378,340,329,333,334,336,337,0,310,0],[399,0,304,323,348,348,345,337,331,327,320,313,308,298,313,0,368,371,374,377,377,0,327,332,334,336,338,336,0,0],[399,307,313,325,351,352,351,344,337,327,322,315,311,302,300,325,368,371,375,379,379,0,0,328,334,340,340,339,335,0],[399,315,319,323,344,355,355,347,337,328,325,318,311,304,299,332,337,0,375,378,341,0,0,326,332,339,341,341,338,333],[398,307,311,322,345,353,349,346,339,330,326,317,312,303,295,329,336,329,0,343,339,0,0,0,0,336,340,338,337,332],[400,396,308,318,345,351,348,344,337,327,323,316,308,303,293,291,325,317,307,0,0,231,229,228,0,318,336,337,334,329],[400,0,306,317,343,347,344,340,333,323,315,310,305,299,290,247,244,235,232,291,0,227,226,222,213,0,313,330,329,325],[399,0,265,274,283,343,341,319,309,296,279,262,270,286,279,251,246,233,231,270,263,257,219,214,209,204,200,315,316,320],[399,0,264,267,271,265,272,255,262,269,270,277,283,277,274,255,0,0,0,35,0,-9,-12,-13,-13,0,161,0,303,317],[400,241,261,266,269,267,283,290,298,285,290,293,289,0,0,0,0,44,0,-12,-10,-10,0,0,0,23,0,-11,299,308],[400,246,263,269,270,265,277,293,305,314,308,302,181,0,0,107,0,-11,0,0,0,0,-11,-10,-13,-13,-15,-13,-13,306],[398,247,264,211,0,0,0,0,0,0,300,0,0,0,0,6,0,0,-16,-16,-11,-10,-13,-12,-10,-9,-12,0,0,0],[248,243,0,173,167,0,0,0,0,0,0,0,78,0,0,0,-16,-15,-15,-16,-9,-13,-14,-11,0,0,0,-14,-13,-12],[0,0,0,0,40,-18,-18,-21,0,0,101,0,0,0,-14,-17,-16,-17,-16,-11,-10,0,0,0,-9,-11,-13,-14,-12,363],[299,299,-15,-19,-20,0,0,0,-21,-19,-4,0,4,-11,-12,-14,-15,-16,0,0,0,-13,-13,-8,-11,-14,-13,-15,-16,353],[302,301,0,0,0,-19,-21,-22,-20,-17,-13,-12,-13,-13,-11,0,0,0,-14,-11,-9,-13,-16,-14,-14,-14,-11,0,0,363],[0,0,-18,-19,-20,-21,-21,-21,-20,-17,-13,-14,0,0,0,-11,-12,-10,-13,-14,-14,-16,-14,-12,0,0,0,-11,-12,394],[0,-17,-20,-16,-15,-20,-22,-21,107,99,0,0,-17,-15,-12,224,229,-13,-14,-17,0,0,0,0,-9,-12,-13,-11,-10,393],[397,200,200,205,213,15,223,229,209,216,213,214,261,206,190,225,231,234,226,220,218,215,209,-11,226,230,233,-14,-13,389],[393,351,201,219,239,310,348,348,305,285,283,272,273,266,271,271,275,242,289,247,219,218,226,237,237,232,239,0,231,389],[396,400,400,395,400,399,399,385,380,365,365,395,388,398,400,400,311,354,296,288,282,279,278,310,276,287,289,295,351,390],[400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,400,401,400,318,320,356,402,402]],"Primary_Key_ID":"674110621606231c695b0f94"}');
        const data = JSON.parse(raw);
        const pickingData = [];

        let lastMouse = null;
        document.body.addEventListener('click', () => {
            if (lastMouse != null) {
                alert("Depth: " + lastMouse);
                lastMouse = null;
            }
        });
        // Alert on body click if lastMouse is not null
        
        init();
        function init() {
            container = document.getElementById('container');
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = -800;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.add(new THREE.AmbientLight(0xcccccc));
            const light = new THREE.DirectionalLight(0xffffff, 3);
            light.position.set(0, 500, 2000);
            scene.add(light);
            scene.rotation.z = Math.PI / 2;
            const defaultMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                flatShading: true,
                vertexColors: true,
                shininess: 250
            });
            // set up the picking texture to use a 32 bit integer so we can write and read integer ids from it
            pickingScene = new THREE.Scene();
            pickingScene.rotation.z = Math.PI / 2;
            pickingTexture = new THREE.WebGLRenderTarget(1, 1, {
                type: THREE.IntType,
                format: THREE.RGBAIntegerFormat,
                internalFormat: 'RGBA32I',
            });
            const pickingMaterial = new THREE.ShaderMaterial({
                glslVersion: THREE.GLSL3,
                vertexShader: /* glsl */`
						attribute int id;
						flat varying int vid;
						void main() {
							vid = id;
							gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
						}
					`,
                fragmentShader: /* glsl */`
						layout(location = 0) out int out_id;
						flat varying int vid;
						void main() {
							out_id = vid;
						}
					`,
            });
            function applyId(geometry, id) {
                const position = geometry.attributes.position;
                const array = new Int16Array(position.count);
                array.fill(id);
                const bufferAttribute = new THREE.Int16BufferAttribute(array, 1, false);
                bufferAttribute.gpuType = THREE.IntType;
                geometry.setAttribute('id', bufferAttribute);
            }
            function applyVertexColors(geometry, color) {
                const position = geometry.attributes.position;
                const colors = [];
                for (let i = 0; i < position.count; i++) {
                    colors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            }
            const geometries = [];
            const matrix = new THREE.Matrix4();
            const quaternion = new THREE.Quaternion();
            const color = new THREE.Color();

            let i = 0;
            for (let x = 0; x < data.Occupancy_Map.length; x++) {
                const arr = data.Occupancy_Map[x]
                for (let y = 0; y < arr.length; y++) {
                    const val = arr[y];
                    const geometry = new THREE.BoxGeometry();
                    const position = new THREE.Vector3();
                    position.x = x * data.Grid_Square_Height_Mm;
                    position.y = y * data.Grid_Square_Width_Mm;
                    position.z = -val / 2;
                    const rotation = new THREE.Euler();
                    rotation.x = Math.PI;
                    rotation.y = Math.PI;
                    rotation.z = Math.PI;
                    const scale = new THREE.Vector3();
                    scale.x = data.Grid_Square_Height_Mm;
                    scale.y = data.Grid_Square_Width_Mm;
                    scale.z = val;
                    quaternion.setFromEuler(rotation);
                    matrix.compose(position, quaternion, scale);
                    geometry.applyMatrix4(matrix);
                    // give the geometry's vertices a random color to be displayed and an integer
                    // identifier as a vertex attribute so boxes can be identified after being merged.
                    const greenAdd = Math.round(val / 900.0 * (0x00ff00 - 0x009900));
                    const green = greenAdd - (greenAdd % 0x0000ff) + 0x339933;
                    let newColor = val < 0 ? 0xddaaaa : green;
                    newColor = val === 0 ? 0xffffff : newColor;
                    applyVertexColors(geometry, color.setHex(newColor));
                    applyId(geometry, i);
                    geometries.push(geometry);
                    pickingData[i] = {
                        position: position,
                        rotation: rotation,
                        scale: scale
                    };
                    i++;
                }
            }
            const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
            scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
            pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));
            highlightBox = new THREE.Mesh(
                new THREE.BoxGeometry(),
                new THREE.MeshLambertMaterial({ color: 0xffff00 })
            );
            scene.add(highlightBox);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);
            controls = new TrackballControls(camera, renderer.domElement);
            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.noZoom = false;
            controls.noPan = false;
            controls.staticMoving = true;
            controls.dynamicDampingFactor = 0.3;
            stats = new Stats();
            container.appendChild(stats.dom);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
        }
        //
        function onPointerMove(e) {
            pointer.x = e.clientX;
            pointer.y = e.clientY;
            lastMouse = null;
        }
        function animate() {
            render();
            stats.update();
        }
        function pick() {
            // render the picking scene off-screen
            // set the view offset to represent just a single pixel under the mouse
            const dpr = window.devicePixelRatio;
            camera.setViewOffset(
                renderer.domElement.width, renderer.domElement.height,
                Math.floor(pointer.x * dpr), Math.floor(pointer.y * dpr),
                1, 1
            );
            // render the scene
            renderer.setRenderTarget(pickingTexture);
            // clear the background to - 1 meaning no item was hit
            clearColor.setRGB(- 1, - 1, - 1);
            renderer.setClearColor(clearColor);
            renderer.render(pickingScene, camera);
            // clear the view offset so rendering returns to normal
            camera.clearViewOffset();
            // create buffer for reading single pixel
            const pixelBuffer = new Int32Array(4);
            // read the pixel
            renderer
                .readRenderTargetPixelsAsync(pickingTexture, 0, 0, 1, 1, pixelBuffer)
                .then(() => {
                    const id = pixelBuffer[0];
                    if (id !== - 1) {
                        // move our highlightBox so that it surrounds the picked object
                        const data = pickingData[id];
                        highlightBox.position.copy(data.position);
                        highlightBox.rotation.copy(data.rotation);
                        highlightBox.scale.copy(data.scale)//.add( offset );
                        highlightBox.visible = true;
                        lastMouse = data.scale.z;
                        console.log("Selected box depth: " + data.scale.z);
                    } else {
                        highlightBox.visible = false;
                    }
                });
        }
        function render() {
            controls.update();
            pick();
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>